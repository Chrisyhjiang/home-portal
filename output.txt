
File: ./src/App.tsx

import React, { useState, useEffect } from "react";
import {
  BrowserRouter as Router,
  Routes,
  Route,
  Navigate,
} from "react-router-dom";
import Desktop from "./features/Desktop/components/Desktop";
import Loading from "./features/Loading/Loading";
import Background from "./features/Background/components/Background";
import Portfolio from "./features/Portfolio/containers/Main";
import { ThemeProvider } from "./context/ThemeContext";
import "./App.css";

const App: React.FC = () => {
  const [isLoading, setIsLoading] = useState(true);
  const [fadeOut, setFadeOut] = useState(false);
  const [fadeIn, setFadeIn] = useState(false);

  useEffect(() => {
    const timer = setTimeout(() => {
      setFadeOut(true);
      setTimeout(() => {
        setIsLoading(false);
        setFadeIn(true);
      }, 500);
    }, 4500);

    return () => clearTimeout(timer);
  }, []);

  return (
    <ThemeProvider>
      <Router>
        <Routes>
          {/* Portfolio Route */}
          <Route
            path="/portfolio"
            element={
              <div className="portfolio-container">
                <Portfolio />
              </div>
            }
          />

          {/* macOS Clone Route */}
          <Route
            path="/desktop"
            element={
              <>
                {isLoading && (
                  <div
                    className={`fixed inset-0 ${
                      fadeOut
                        ? "opacity-0 transition-opacity duration-1000"
                        : ""
                    }`}
                  >
                    <Loading />
                  </div>
                )}
                <div
                  className={`relative h-screen w-screen ${
                    fadeIn
                      ? "opacity-100 transition-opacity duration-1000"
                      : "opacity-0"
                  }`}
                >
                  <Background />
                  <div className="relative">
                    <Desktop />
                  </div>
                </div>
              </>
            }
          />

          {/* Default Route - Redirect to Portfolio */}
          <Route path="/" element={<Navigate to="/portfolio" replace />} />
        </Routes>
      </Router>
    </ThemeProvider>
  );
};

export default App;

File: ./src/main.tsx

import { createRoot } from "react-dom/client";
import "./styles/index.css";
import App from "./App.tsx";

createRoot(document.getElementById("root")!).render(
  // 🚨 Remove StrictMode to avoid warnings
  <App />
);

File: ./src/context/ThemeContext.tsx

import React, { createContext, useContext, useState, useEffect } from "react";

type Theme = "light" | "dark";

interface ThemeContextType {
  theme: Theme;
  toggleTheme: () => void;
  colors: {
    background: string;
    text: string;
    primary: string;
    secondary: string;
    accent: string;
    surface: string;
    border: string;
  };
}

const lightColors = {
  background: "#ffffff",
  text: "#2d3748",
  primary: "#3182ce",
  secondary: "#4a5568",
  accent: "#ed64a6",
  surface: "#f7fafc",
  border: "#e2e8f0",
};

const darkColors = {
  background: "#1a202c",
  text: "#f7fafc",
  primary: "#63b3ed",
  secondary: "#a0aec0",
  accent: "#f687b3",
  surface: "#2d3748",
  border: "#4a5568",
};

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [theme, setTheme] = useState<Theme>(() => {
    const savedTheme = localStorage.getItem("theme");
    return (savedTheme as Theme) || "light";
  });

  const colors = theme === "light" ? lightColors : darkColors;

  useEffect(() => {
    localStorage.setItem("theme", theme);
    document.documentElement.setAttribute("data-theme", theme);
  }, [theme]);

  const toggleTheme = () => {
    setTheme((prev) => (prev === "light" ? "dark" : "light"));
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme, colors }}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context;
};

File: ./src/features/Background/components/Background.tsx

import React, { useEffect, useRef, useState } from "react";
import * as PIXI from "pixi.js";
import { DisplacementFilter, Filter, Sprite } from "pixi.js";

// Available wallpapers and their depth maps
const WALLPAPERS = [
  { image: "anime", ext: "png" },
  { image: "astro", ext: "jpg" },
  { image: "car", ext: "jpg" },
  { image: "castle", ext: "jpg" },
  { image: "cave", ext: "jpg" },
  { image: "cyber", ext: "png" },
  { image: "fantasy", ext: "jpg" },
  { image: "fantasy2", ext: "jpg" },
  { image: "northernlights", ext: "jpg" },
  { image: "onepiece", ext: "jpg" },
  { image: "sunrise", ext: "jpg" },
  { image: "waterfall", ext: "jpg" },
];

const Background: React.FC = () => {
  const containerRef = useRef<HTMLDivElement>(null);
  const appRef = useRef<PIXI.Application | null>(null);
  const backgroundRef = useRef<PIXI.Sprite | null>(null);
  const displacementFilterRef = useRef<DisplacementFilter | null>(null);
  // Add refs for smooth movement
  const targetValues = useRef({ x: 0, y: 0 });
  const currentValues = useRef({ x: 0, y: 0 });
  const [currentWallpaper, setCurrentWallpaper] = useState(
    () => WALLPAPERS[Math.floor(Math.random() * WALLPAPERS.length)]
  );

  const changeWallpaper = async (app: PIXI.Application) => {
    if (!backgroundRef.current) return;

    // Fade out
    const fadeOutTween = { alpha: 1 };
    const fadeOutDuration = 300; // 0.3 seconds
    const startTime = Date.now();

    const fadeOut = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / fadeOutDuration, 1);
      fadeOutTween.alpha = 1 - progress;

      if (backgroundRef.current) {
        backgroundRef.current.alpha = fadeOutTween.alpha;
      }

      if (progress < 1) {
        requestAnimationFrame(fadeOut);
      } else {
        // After fade out, load new wallpaper
        loadNewWallpaper();
      }
    };

    fadeOut();

    const loadNewWallpaper = async () => {
      // Choose new random wallpaper (different from current)
      let newWallpaper;
      do {
        newWallpaper =
          WALLPAPERS[Math.floor(Math.random() * WALLPAPERS.length)];
      } while (newWallpaper.image === currentWallpaper.image);

      try {
        const [mainTexture, depthTexture] = await Promise.all([
          PIXI.Assets.load(
            `/background/image/${newWallpaper.image}.${newWallpaper.ext}`
          ),
          PIXI.Assets.load(`/background/depthmap/${newWallpaper.image}.png`),
        ]);

        if (backgroundRef.current) {
          backgroundRef.current.texture = mainTexture;
          // Apply dark tint to new background
          backgroundRef.current.tint = 0xcccccc;
          backgroundRef.current.alpha = 0.8;
          // Create a new displacement filter with the new depth map
          const newDisplacementFilter = new DisplacementFilter(
            new PIXI.Sprite(depthTexture)
          );
          newDisplacementFilter.scale.x = 15;
          newDisplacementFilter.scale.y = 15;
          backgroundRef.current.filters = [newDisplacementFilter];
          displacementFilterRef.current = newDisplacementFilter;
        }

        setCurrentWallpaper(newWallpaper);

        // Fade in
        const fadeInTween = { alpha: 0 };
        const fadeInDuration = 300; // 0.3 seconds
        const fadeInStart = Date.now();

        const fadeIn = () => {
          const elapsed = Date.now() - fadeInStart;
          const progress = Math.min(elapsed / fadeInDuration, 1);
          fadeInTween.alpha = progress;

          if (backgroundRef.current) {
            backgroundRef.current.alpha = fadeInTween.alpha;
          }

          if (progress < 1) {
            requestAnimationFrame(fadeIn);
          }
        };

        fadeIn();
      } catch (error) {
        console.error("Error loading new wallpaper:", error);
      }
    };
  };

  useEffect(() => {
    if (!containerRef.current) return;

    console.log("Initializing Background component");

    const canvas = document.createElement("canvas");
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    containerRef.current.appendChild(canvas);

    const app = new PIXI.Application();
    app.init({
      width: window.innerWidth,
      height: window.innerHeight,
      backgroundColor: 0x000000,
      resizeTo: window,
      antialias: true,
      view: canvas,
    });

    appRef.current = app;
    console.log("PIXI Application created");

    const setup = async () => {
      try {
        console.log("Loading textures...");
        const [mainTexture, depthTexture] = await Promise.all([
          PIXI.Assets.load(
            `/background/image/${currentWallpaper.image}.${currentWallpaper.ext}`
          ),
          PIXI.Assets.load(
            `/background/depthmap/${currentWallpaper.image}.png`
          ),
        ]);

        console.log("Textures loaded successfully");

        const background = new PIXI.Sprite(mainTexture);
        const depthMap = new PIXI.Sprite(depthTexture);
        backgroundRef.current = background;

        console.log("Sprites created");

        // Apply dark tint to background
        background.tint = 0xcccccc; // Lighter gray tint (80% of white)
        background.alpha = 0.8; // 80% opacity

        background.width = window.innerWidth;
        background.height = window.innerHeight;
        // Set pivot point to center for rotation
        background.anchor.set(0.5);
        // Adjust position to compensate for centered anchor
        background.position.set(window.innerWidth / 2, window.innerHeight / 2);
        app.stage.addChild(background);

        depthMap.width = window.innerWidth;
        depthMap.height = window.innerHeight;
        // Also center the depth map
        depthMap.anchor.set(0.5);
        depthMap.position.set(window.innerWidth / 2, window.innerHeight / 2);
        depthMap.visible = false;
        app.stage.addChild(depthMap);

        console.log("Sprites added to stage");

        const displacementFilter = new DisplacementFilter(depthMap);
        displacementFilter.scale.x = 15;
        displacementFilter.scale.y = 15;
        background.filters = [displacementFilter];
        displacementFilterRef.current = displacementFilter;

        console.log("Displacement filter set up");

        // Set up animation loop for smooth transitions
        const animate = () => {
          if (backgroundRef.current && displacementFilterRef.current) {
            // Smooth displacement movement
            currentValues.current.x +=
              (targetValues.current.x - currentValues.current.x) * 0.1;
            currentValues.current.y +=
              (targetValues.current.y - currentValues.current.y) * 0.1;

            // Apply values
            displacementFilterRef.current.scale.x = currentValues.current.x;
            displacementFilterRef.current.scale.y = currentValues.current.y;
          }
          requestAnimationFrame(animate);
        };

        animate();

        // Set up wallpaper rotation interval
        const wallpaperInterval = setInterval(() => {
          changeWallpaper(app);
        }, 10000);

        const onMouseMove = (e: MouseEvent) => {
          if (!displacementFilterRef.current) return;

          const { clientX, clientY } = e;
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;

          // Calculate normalized position (-1 to 1)
          const normalizedX = (clientX - centerX) / (window.innerWidth / 2);
          const normalizedY = (clientY - centerY) / (window.innerHeight / 2);

          // Update target values with displacement only
          targetValues.current.x = normalizedX * 20;
          targetValues.current.y = normalizedY * 20;
        };

        window.addEventListener("mousemove", onMouseMove);

        const onResize = () => {
          if (!appRef.current) return;
          background.width = window.innerWidth;
          background.height = window.innerHeight;
          // Update position on resize
          background.position.set(
            window.innerWidth / 2,
            window.innerHeight / 2
          );

          depthMap.width = window.innerWidth;
          depthMap.height = window.innerHeight;
          depthMap.position.set(window.innerWidth / 2, window.innerHeight / 2);
        };

        window.addEventListener("resize", onResize);

        return () => {
          window.removeEventListener("mousemove", onMouseMove);
          window.removeEventListener("resize", onResize);
          clearInterval(wallpaperInterval);
        };
      } catch (error) {
        console.error("Error in setup:", error);
        if (error instanceof Error) {
          console.error("Error message:", error.message);
          console.error("Error stack:", error.stack);
        }
        throw error;
      }
    };

    let cleanup: (() => void) | undefined;
    setup()
      .then((cleanupFn) => {
        cleanup = cleanupFn;
        console.log("Setup completed successfully");
      })
      .catch((error) => {
        console.error("Failed to complete setup:", error);
      });

    return () => {
      cleanup?.();
      if (appRef.current) {
        console.log("Destroying PIXI application");
        appRef.current.destroy(true);
      }
      canvas.remove();
    };
  }, []);

  return <div ref={containerRef} className="fixed inset-0 -z-10" />;
};

export default Background;

File: ./src/features/Loading/Loading.tsx

import React from 'react';
import './styles/Loading.css'; // Import the CSS file for styling

const Loading: React.FC = () => {
    return (
        <div className="loading-container">
            <div id='loader'>
                <div id='title' className='flex'>
                    <p className='loading-text'>LOADING</p>
                    <div className='therefore'>∴</div>
                    <p className="loading-number">%</p>
                </div>
                <div id='loading-bar-border'>
                    <div className='loading-bar'></div>
                </div>
                <div id='warning'>
                    <p>
                        <div className='exclamation'>!</div>
                        CAUTION, Do not turn off.
                    </p>
                    <div id='line-cascates'></div>
                </div>
            </div>
        </div>
    );
};

export default Loading;

File: ./src/features/PDFViewer/components/PDFViewer.test.tsx

import { render } from "@testing-library/react";
import PDFViewer from "./PDFViewer";

test("renders PDFViewer component", () => {
  // Providing the required 'onClose' prop as a dummy function
  render(<PDFViewer onClose={() => {}} />);
});

File: ./src/features/PDFViewer/components/PDFViewer.tsx

import React from "react";

interface PDFViewerProps {
  filePath?: string;
  onClose: () => void;
}

const PDFViewer: React.FC<PDFViewerProps> = ({ filePath }) => {
  if (!filePath || !filePath.endsWith(".pdf")) {
    return (
      <div className="p-4 text-white bg-red-500">No valid PDF selected.</div>
    );
  }

  const correctedPath = filePath.startsWith("/docs/")
    ? filePath
    : `/docs/${filePath.replace(/^\/?public\//, "")}`;

  return (
    <div
      style={{
        width: "100%",
        height: "100%",
        overflow: "hidden",
        backgroundColor: "#2e2e2e",
      }}
    >
      <iframe
        src={`${correctedPath}#toolbar=1&navpanes=0&scrollbar=1`}
        style={{
          width: "100%",
          height: "100%",
          border: "none",
        }}
        title="PDF viewer"
      />
    </div>
  );
};

export default PDFViewer;

File: ./src/features/Terminal/components/Terminal.tsx

import { useState } from "react";
import { useAppStore } from "@hooks/useAppStore";

export default function Terminal() {
  const [output, setOutput] = useState<string[]>(["Welcome to Terminal"]);
  const [input, setInput] = useState("");
  const { openApp } = useAppStore();

  const commands: Record<string, () => string> = {
    ls: () => "Resume.pdf  Project1  Project2",
    clear: () => {
      setOutput([]);
      return "";
    },
    help: () =>
      "Available commands:\n- ls (List files)\n- show <file> (View PDF files)\n- clear (Clear terminal)\n- help (Show this help message)",
  };

  const handleCommand = (event: React.FormEvent) => {
    event.preventDefault();
    let newOutput = [...output, `$ ${input}`];

    const args = input.split(" ");
    const command = args[0];

    if (command === "show" && args[1]?.endsWith(".pdf")) {
      const filePath = `/docs/${args[1]}`;
      console.log("Opening PDF:", filePath);
      newOutput.push(`Opening ${args[1]}...`);
      openApp("Resume", { filePath });
    } else if (commands[command]) {
      newOutput.push(commands[command]());
    } else {
      newOutput.push("Command not found. Type 'help' for a list of commands.");
    }

    setOutput(newOutput);
    setInput("");
  };

  return (
    <div className="p-4 bg-black text-green-400 font-mono w-full h-full overflow-auto">
      {output.map((line, index) => (
        <div key={index}>{line}</div>
      ))}
      <form onSubmit={handleCommand} className="flex">
        <span className="mr-2">$</span>
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          className="bg-black border-none outline-none text-green-400 flex-grow"
          autoFocus
        />
      </form>
    </div>
  );
}

File: ./src/features/Terminal/components/Terminal.test.tsx

import { render } from "@testing-library/react";
import Terminal from "./Terminal";

test("renders Terminal component", () => {
  render(<Terminal />);
  // Add more specific tests here
});

File: ./src/features/Desktop/components/Desktop.tsx

import { useAppStore } from "@hooks/useAppStore";
import Topbar from "@features/Topbar/components/Topbar";
import Dock from "@features/Dock/components/Dock";
import Finder from "@features/Finder/components/Finder";
import Terminal from "@features/Terminal/components/Terminal";
import Window from "@features/Window/components/Window";
import PDFViewer from "@features/PDFViewer/components/PDFViewer";
import { useRef, useEffect } from "react";
import { apps } from "@shared/constants";
import React from "react";
import { PanInfo } from "framer-motion";
import AppIcon from "@shared/components/AppIcon/AppIcon";
import { Rnd } from "react-rnd";
import { useWindowOpener } from "@hooks/useWindowOpener";
import { useWindowManager } from "@hooks/useWindowManager";
import Readme from "@/features/Readme/components/Readme";

interface DesktopIconProps {
  app: {
    name: string;
    icon: string;
    position?: { x: number; y: number };
  };
  onOpen: () => void;
  onDragEnd: (
    event: MouseEvent | TouchEvent | PointerEvent,
    info: PanInfo
  ) => void;
}

const DesktopIcon: React.FC<DesktopIconProps> = ({
  app,
  onOpen,
  onDragEnd,
}) => {
  const { desktopIcons, updateIconPosition } = useAppStore();
  const iconState = desktopIcons.find((icon) => icon.app === app.name);

  const handleDragStop = (e: any, data: { x: number; y: number }) => {
    const newPosition = { x: data.x, y: data.y };
    updateIconPosition(app.name, newPosition);
    onDragEnd(e, {
      point: newPosition,
      delta: { x: 0, y: 0 },
      offset: { x: data.x, y: data.y },
      velocity: { x: 0, y: 0 },
    });
  };

  return (
    <Rnd
      position={{
        x: iconState?.position.x ?? 20,
        y: iconState?.position.y ?? 20,
      }}
      size={{ width: 100, height: 100 }}
      onDragStop={handleDragStop}
      enableResizing={false}
      bounds="parent"
    >
      <div
        className="desktop-icon flex flex-col items-center gap-2 p-2 rounded hover:bg-white/10 group cursor-pointer"
        onClick={(e) => {
          e.stopPropagation();
          console.log("Icon clicked:", app.name);
          onOpen();
        }}
      >
        <div className="w-20 h-20 flex items-center justify-center rounded-full bg-gray-800 shadow-md border border-gray-300 overflow-hidden">
          <AppIcon icon={app.icon} name={app.name} />
        </div>
        <span
          className="text-white text-xs px-2 py-1 rounded-md opacity-0 group-hover:opacity-100 transition-opacity"
          style={{
            textShadow: "0 1px 3px rgba(0, 0, 0, 0.8)",
            backgroundColor: "rgba(0, 0, 0, 0.6)",
          }}
        >
          {app.name}
        </span>
      </div>
    </Rnd>
  );
};

export default function Desktop() {
  const {
    openApps,
    openApp,
    closeApp,
    minimizeApp,
    restoreApp,
    desktopIcons,
    updateIconPosition,
    initializeDesktopIcons,
  } = useAppStore();

  const dragRefs = useRef<Record<string, React.RefObject<HTMLDivElement>>>({});
  const { openOrRestoreWindow } = useWindowOpener();
  const { windowStack } = useWindowManager();

  // Initialize desktop icons if empty
  useEffect(() => {
    if (desktopIcons.length === 0) {
      initializeDesktopIcons();
    }
  }, [desktopIcons.length, initializeDesktopIcons]);

  // ✅ Ensure refs exist for all openApps (without reinitializing on every render)
  useEffect(() => {
    openApps.forEach(({ appName }) => {
      if (!dragRefs.current[appName]) {
        dragRefs.current[appName] = { current: null };
      }
    });
  }, [openApps]);

  const handleMinimize = (appName: string) => {
    minimizeApp(appName);
  };

  const handleDockIconClick = (appName: string) => {
    const app = openApps.find((a) => a.appName === appName);

    if (app) {
      if (app.minimized) {
        // If app is minimized, restore it
        console.log(`[${appName}] Restoring minimized app`);
        restoreApp(appName);
      }
      // If app is already open and not minimized, do nothing
    } else {
      // If app isn't open at all, open it
      console.log(`[${appName}] Opening new app`);
      const appConfig = apps.find((a) => a.name === appName);
      if (appName === "Resume" && appConfig?.defaultFile) {
        openApp(appName, { filePath: appConfig.defaultFile });
      } else {
        openApp(appName);
      }
    }
  };

  return (
    <div
      className="h-screen w-screen relative flex flex-col overflow-hidden pt-12 pb-20"
      onClick={(_) => console.log("Desktop clicked")}
    >
      <Topbar />

      {/* Desktop Icons Layer */}
      <div
        className="absolute inset-0 pt-12 z-10"
        onClick={(_) => console.log("Icons container clicked")}
      >
        <div
          className="relative w-full h-full"
          onClick={(_) => console.log("Inner icons container clicked")}
        >
          {apps.map((app) => (
            <DesktopIcon
              key={app.name}
              app={app}
              onOpen={() => openOrRestoreWindow(app.name)}
              onDragEnd={(_, info) =>
                updateIconPosition(app.name, {
                  x: info.point.x,
                  y: info.point.y,
                })
              }
            />
          ))}
          {/* GitHub Icon */}
        </div>
      </div>

      {/* Windows Layer */}
      {openApps.length > 0 && (
        <div className="relative z-30">
          {openApps.map(({ appName, filePath, minimized, startPosition }) => {
            const initialPosition = startPosition || {
              x: window.innerWidth / 2 - 300,
              y: window.innerHeight / 2 - 200,
            };

            // Calculate z-index based on window stack position
            const zIndex = windowStack.indexOf(appName);
            const baseZIndex = 30;
            const calculatedZIndex =
              zIndex === -1 ? baseZIndex : baseZIndex + zIndex;

            return (
              <div
                key={appName}
                style={{
                  position: "absolute",
                  zIndex: calculatedZIndex,
                  display: minimized ? "none" : "block",
                }}
              >
                <Window
                  title={appName}
                  isVisible={true}
                  onClose={() => closeApp(appName)}
                  onMinimize={() => handleMinimize(appName)}
                  startPosition={initialPosition}
                  windowId={appName}
                >
                  {appName === "Finder" && <Finder />}
                  {appName === "Terminal" && <Terminal />}
                  {appName === "Resume" && (
                    <PDFViewer
                      filePath={filePath}
                      onClose={() => closeApp(appName)}
                    />
                  )}
                  {appName === "Readme" && <Readme />}
                </Window>
              </div>
            );
          })}
        </div>
      )}

      {/* Dock - Topmost layer */}
      <div className="z-40">
        <Dock openApp={handleDockIconClick} />
      </div>
    </div>
  );
}

File: ./src/features/Desktop/components/Desktop.test.tsx

import { render } from "@testing-library/react";
import Desktop from "./Desktop";

test("renders Desktop component", () => {
  render(<Desktop />);
  // Add more specific tests here
});

File: ./src/features/Readme/components/Readme.tsx

import React from "react";
import "../styles/styles.css";

const Readme: React.FC = () => {
  return (
    <div className="notes-container">
      <h1 className="notes-title">Welcome!</h1>
      <div className="notes-content">
        Howdy! This is my interactive mac-os clone personal portfolio, feel free
        to do whatever your heart desires. You can: • Open the Terminal • Check
        out my Resume • Visit my GitHub • Explore the Finder Have fun exploring!
        🚀
      </div>
    </div>
  );
};

export default Readme;

File: ./src/features/Window/components/Window.test.tsx

import { render } from "@testing-library/react";
import Window from "./Window";
import Finder from "../../Finder/components/Finder";
import Dock from "../../Dock/components/Dock";

test("renders Window component", () => {
  render(
    <Window
      title="Test Window"
      isVisible={true}
      onClose={() => {}}
      onMinimize={() => {}}
      windowId="test-window"
    >
      <div>Window Content</div>
    </Window>
  );
  // Add more specific tests here
});

test("renders Finder component", () => {
  render(<Finder />);
});

test("renders Dock component", () => {
  render(<Dock openApp={() => {}} />);
});

File: ./src/features/Window/components/Window.tsx

import React, { useState, useEffect } from "react";
import { Rnd } from "react-rnd";
import { motion, AnimatePresence } from "framer-motion";
import "../styles/Window.css";
import { useWindowManager } from "../../../hooks/useWindowManager";

interface WindowProps {
  title: string;
  isVisible: boolean;
  onClose: () => void;
  onMinimize: () => void;
  isMaximizedAlready?: boolean;
  children: React.ReactNode;
  startPosition?: { x: number; y: number };
  windowId: string;
}

const Window: React.FC<WindowProps> = ({
  title,
  isVisible,
  onClose,
  onMinimize,
  isMaximizedAlready = false,
  children,
  startPosition = {
    x: (window.innerWidth - 600) / 2,
    y: (window.innerHeight - 400) / 2,
  },
  windowId,
}) => {
  console.log(
    "Window component initialized with windowId:",
    windowId,
    "and title:",
    title
  );

  const [size, setSize] = useState(() => {
    if (title === "Resume") {
      return {
        width: Math.min(window.innerWidth * 0.6, 900),
        height: Math.min(window.innerHeight * 0.6, 800),
      };
    }
    return { width: 600, height: 400 };
  });
  const [position, setPosition] = useState(startPosition);
  const [isMaximized, setIsMaximized] = useState(isMaximizedAlready);
  const windowClassName = `window-rnd-${title
    .toLowerCase()
    .replace(/\s+/g, "-")}`;
  const [isAnimating] = useState(false);
  const [preMaximizedState, setPreMaximizedState] = useState<{
    position: { x: number; y: number };
    size: { width: number; height: number };
  } | null>(null);
  const [isClosing, setIsClosing] = useState(false);
  const { bringToFront, windowStack, registerWindow } = useWindowManager();

  useEffect(() => {
    if (title === "Resume") {
      const width = isMaximized
        ? Math.min(window.innerWidth * 0.8, 1200)
        : Math.min(window.innerWidth * 0.6, 900);

      const height = isMaximized
        ? Math.min(window.innerHeight * 0.8, 1000)
        : Math.min(window.innerHeight * 0.6, 800);

      setSize({ width, height });
      setPosition({
        x: (window.innerWidth - width) / 2,
        y: (window.innerHeight - height) / 2,
      });
    }
  }, [isMaximized, title]);

  useEffect(() => {
    if (isMaximized) {
      const lastWindowState = {
        position,
        size,
      };

      // Calculate 75% of screen dimensions
      const maxWidth = window.innerWidth * 0.75;
      const maxHeight = window.innerHeight * 0.75;

      // Calculate position to center the window
      const centerX = (window.innerWidth - maxWidth) / 2;
      const centerY = (window.innerHeight - maxHeight) / 2;

      setSize({ width: maxWidth, height: maxHeight });
      setPosition({ x: centerX, y: centerY });

      setPreMaximizedState(lastWindowState);
    } else if (preMaximizedState) {
      setSize(preMaximizedState.size);
      setPosition(preMaximizedState.position);
    }
  }, [isMaximized]);

  useEffect(() => {
    console.log("Window registration effect - windowId:", windowId);
    if (windowId) {
      registerWindow(windowId);
    } else {
      console.warn(
        "Attempting to register window but windowId is undefined for title:",
        title
      );
    }
  }, [windowId, registerWindow, title]);

  const handleMaximize = () => {
    if (isMaximized) {
      // When un-maximizing, restore to previous size and position
      if (preMaximizedState) {
        setSize(preMaximizedState.size);
        setPosition(preMaximizedState.position);
      }
    } else {
      // When maximizing, save current state and set new size
      setPreMaximizedState({
        position,
        size,
      });
      const width = window.innerWidth * 0.8;
      const height = window.innerHeight * 0.8;
      setSize({ width, height });
      setPosition({
        x: (window.innerWidth - width) / 2,
        y: (window.innerHeight - height) / 2,
      });
    }
    setIsMaximized(!isMaximized);
  };

  const handleClose = () => {
    setIsClosing(true);
    // Wait for animation to complete before calling onClose
    setTimeout(() => onClose(), 200);
  };

  const handleClick = () => {
    console.log("Window clicked - windowId:", windowId, "title:", title);
    if (windowId) {
      bringToFront(windowId);
    } else {
      console.error("windowId is undefined for window title:", title);
    }
  };

  const zIndex = windowStack.indexOf(windowId);

  return (
    <AnimatePresence>
      {isVisible && !isClosing && (
        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          exit={{ opacity: 0, scale: 0.95 }}
          transition={{ duration: 0.2 }}
          onClick={handleClick}
        >
          <Rnd
            size={size}
            position={position}
            onDragStop={(_, d) => {
              // Ensure the window doesn't go above the topbar
              const y = Math.max(5, d.y);
              setPosition({ x: d.x, y });
            }}
            bounds="window"
            onResizeStop={(_, __, ref, ___, position) => {
              setSize({
                width: ref.offsetWidth,
                height: ref.offsetHeight,
              });
              // Ensure position stays within bounds after resize
              const y = Math.max(5, position.y);
              setPosition({ x: position.x, y });
            }}
            dragHandleClassName="window-top-bar"
            minWidth={300}
            minHeight={200}
            disableDragging={false}
            enableResizing={true}
            className={`${windowClassName} ${windowId}`}
            style={{
              zIndex,
              transition: isAnimating ? "width 0.3s, height 0.3s" : "none",
            }}
          >
            <div
              className={`window-container ${isMaximized ? "maximized" : ""}`}
            >
              <div className="window-top-bar">
                <div className="window-controls">
                  <button onClick={onMinimize} className="minimize-button">
                    _
                  </button>
                  <button onClick={handleMaximize}>
                    {isMaximized ? "❐" : "[]"}
                  </button>
                  <button onClick={handleClose}>X</button>
                </div>
                <span className="window-title">{title}</span>
              </div>
              <div
                className="window-content"
                style={{ height: "calc(100% - 30px)" }}
              >
                {children}
              </div>
            </div>
          </Rnd>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default Window;

File: ./src/features/Finder/components/Finder.tsx

import { useAppStore } from "@hooks/useAppStore";
import "../styles/Finder.css"; // Ensure you have this file for styling

export default function Finder() {
  const { openApp } = useAppStore(); // ✅ Use store to open PDFViewer

  const files = [
    { name: "Resume.pdf", path: "/docs/Resume.pdf" }, // ✅ Ensure exact casing
    { name: "Project 1", path: "https://github.com/Chrisyhjiang/project1" },
    { name: "Project 2", path: "https://github.com/Chrisyhjiang/project2" },
  ];

  return (
    <div className="finder-container">
      <h2 className="finder-title">Finder</h2>
      <ul className="finder-list">
        {files.map((file) => (
          <li key={file.name} className="finder-item">
            {file.path.startsWith("http") ? (
              <a
                href={file.path}
                target="_blank"
                rel="noopener noreferrer"
                className="finder-link"
              >
                {file.name}
              </a>
            ) : (
              <button
                onClick={() => openApp("Resume", { filePath: file.path })}
                className="finder-button"
              >
                {file.name}
              </button>
            )}
          </li>
        ))}
      </ul>
    </div>
  );
}

File: ./src/features/Finder/components/Finder.test.tsx

import { render } from "@testing-library/react";
import Finder from "./Finder";

test("renders Finder component", () => {
  render(<Finder />);
  // Add more specific tests here
});

File: ./src/features/Portfolio/portfolio.ts

export const profile = {
  name: "Christopher Jiang",
  role: "Software Developer",
  description: "Computer Science Student at the University of Waterloo.",
};

export const social = [
  { name: "GitHub", link: "https://github.com/Chrisyhjiang" },
  {
    name: "LinkedIn",
    link: "https://www.linkedin.com/in/christopher-jiang-3b8a30223/",
  },
];

export const brand = "CJ";

export const greeting = {
  title: "Hi there 👋",
  logo_name: "christopher.j()",
  full_name: "Christopher Jiang",
  subTitle: "Full Stack Developer, Open Source Enthusiast 🔥. Always learning.",
};

export const work = [
  // Add your projects here
];

export const stack = [
  {
    name: "Front End",
    items: [
      { name: "HTML" },
      { name: "CSS" },
      { name: "Javascript" },
      { name: "Typescript" },
      { name: "React" },
      { name: "Angular" },
    ],
  },
  {
    name: "Back End",
    items: [
      { name: "NodeJS" },
      { name: "MongoDB" },
      { name: "MySQL" },
      { name: "Python" },
      { name: "Kotlin" },
      { name: "Golang" },
      { name: "Java" },
    ],
  },
  {
    name: "Tools",
    items: [
      { name: "Git" },
      { name: "Docker" },
      { name: "Kubernetes" },
      { name: "Postman" },
      { name: "Azure" },
      { name: "Google Cloud" },
      { name: "AWS" },
    ],
  },
];

export const experiences = [
  // Add your experiences here
];

export const contact = {
  description:
    "For any opportunities or questions, please feel free to contact me.",
  email: "christopher.jiang@uwaterloo.ca",
};

File: ./src/features/Portfolio/components/card/Card.tsx

import React from "react";
import { SiGithub } from "react-icons/si";
import { RiArrowRightLine } from "react-icons/ri";
import Icon from "../icon/Icon";
import "./Card.css";

interface CardProps {
  name: string;
  description: string;
  stack: Array<{
    icon: React.ComponentType;
    name: string;
  }>;
  linkProject: string;
  linkGithub: string;
  theme: string;
  colors: {
    background: string;
    text: string;
    primary: string;
    secondary: string;
    accent: string;
    surface: string;
    border: string;
  };
}

const Card: React.FC<CardProps> = ({
  name,
  description,
  stack,
  linkProject,
  linkGithub,
  colors,
}) => {
  return (
    <div
      className="Card"
      style={{
        backgroundColor: colors.surface,
        color: colors.text,
        border: `1px solid ${colors.accent}`,
      }}
    >
      <h3 className="Card-h3">{name}</h3>
      <p className="Card-description">{description}</p>
      <div className="Card-tech">
        {stack.map((tech, index) => (
          <Icon icon={tech.icon} key={`${tech.name}-${index}`} />
        ))}
      </div>
      <div className="Card-links">
        <a
          href={linkProject}
          rel="noreferrer"
          className="Card-link-project"
          target="_blank"
          style={{ color: colors.accent }}
        >
          View Project <RiArrowRightLine className="Card-icon-arrow" />
        </a>
        <a
          href={linkGithub}
          rel="noreferrer"
          className="Card-link-github"
          target="_blank"
          style={{ color: colors.accent }}
        >
          <SiGithub className="Card-icon-github" />
        </a>
      </div>
    </div>
  );
};

export default Card;

File: ./src/features/Portfolio/components/socialMedia/SocialMedia.tsx

import React from "react";
import { social } from "../../portfolio";
import "./SocialMedia.css";

const SocialMedia: React.FC = () => {
  return (
    <div className="social-media">
      {social.map((platform, index) => (
        <a
          key={index}
          href={platform.link}
          className="social-media-link"
          target="_blank"
          rel="noopener noreferrer"
          aria-label={`Visit my ${platform.name}`}
        >
          {platform.name}
        </a>
      ))}
    </div>
  );
};

export default SocialMedia;

File: ./src/features/Portfolio/components/icon/Icon.tsx

import React from "react";

interface IconProps {
  icon: React.ComponentType<any>;
  [key: string]: any;
}

const Icon: React.FC<IconProps> = ({ icon: TheIcon, ...restProps }) => {
  return <TheIcon {...restProps} />;
};

export default Icon;

File: ./src/features/Portfolio/components/header/Header.tsx

import React, { useState, useEffect } from 'react';
import { useTheme } from '../../../../context/ThemeContext';
import { FiSun, FiMoon, FiMenu, FiX } from 'react-icons/fi';
import './Header.css';

const Header: React.FC = () => {
  const { theme, toggleTheme, colors } = useTheme();
  const [isScrolled, setIsScrolled] = useState(false);
  const [isMenuOpen, setIsMenuOpen] = useState(false);

  useEffect(() => {
    const handleScroll = () => {
      setIsScrolled(window.scrollY > 50);
    };

    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  const scrollToSection = (sectionId: string) => {
    const element = document.getElementById(sectionId);
    if (element) {
      element.scrollIntoView({ behavior: 'smooth' });
      setIsMenuOpen(false);
    }
  };

  return (
    <header
      className={`portfolio-header ${isScrolled ? 'scrolled' : ''}`}
      style={{
        backgroundColor: isScrolled ? colors.surface : 'transparent',
        borderBottom: isScrolled ? `1px solid ${colors.border}` : 'none',
      }}
    >
      <div className="header-content">
        <h1 className="logo" style={{ color: colors.text }}>CJ</h1>
        
        <button className="mobile-menu-btn" onClick={() => setIsMenuOpen(!isMenuOpen)}>
          {isMenuOpen ? <FiX /> : <FiMenu />}
        </button>

        <nav className={`nav-links ${isMenuOpen ? 'open' : ''}`}>
          <button onClick={() => scrollToSection('about')}>About</button>
          <button onClick={() => scrollToSection('education')}>Education</button>
          <button onClick={() => scrollToSection('experience')}>Experience</button>
          <button onClick={() => scrollToSection('skills')}>Skills</button>
          <button onClick={() => scrollToSection('projects')}>Projects</button>
          <button onClick={() => scrollToSection('contact')}>Contact</button>
          <button 
            className="theme-toggle"
            onClick={toggleTheme}
            aria-label="Toggle theme"
          >
            {theme === 'light' ? <FiMoon /> : <FiSun />}
          </button>
        </nav>
      </div>
    </header>
  );
};

export default Header;

File: ./src/features/Portfolio/containers/experience/Experience.tsx

import React from "react";
import { experiences } from "../../portfolio";
import {
  VerticalTimeline,
  VerticalTimelineElement,
} from "react-vertical-timeline-component";
import "react-vertical-timeline-component/style.min.css";
import "./Experience.css";

interface ExperienceProps {
  theme: string;
  colors: {
    background: string;
    text: string;
    primary: string;
    secondary: string;
    accent: string;
    surface: string;
    border: string;
  };
}

const Experience: React.FC<ExperienceProps> = ({ theme, colors }) => {
  return (
    <section className="Experience section" id="experience">
      <div className="container">
        <h2
          className="Experience-h2 section-head"
          style={{ color: colors.text }}
        >
          Experience
        </h2>
        <div className="Experience-wrapper">
          <VerticalTimeline>
            {experiences.map((experience, index) => (
              <VerticalTimelineElement
                key={`${experience.Company}-${index}`}
                date={
                  <span
                    className="date-style"
                    style={{ color: colors.text }}
                  >{`${experience.StartDate} - ${experience.EndDate}`}</span>
                }
                iconStyle={{
                  background: colors.accent,
                  color: colors.background,
                }}
                icon={
                  <img
                    alt=""
                    src={experience.Icon}
                    style={{
                      width: "100%",
                      height: "100%",
                      borderRadius: "50%",
                      objectFit: "cover",
                    }}
                  />
                }
                contentStyle={{
                  background: colors.surface,
                  color: colors.text,
                  border: `1px solid ${colors.accent}`,
                }}
                contentArrowStyle={{
                  borderRight: `7px solid ${colors.accent}`,
                }}
              >
                <h3 className="vertical-timeline-element-title">
                  {experience.Role}, {experience.Company}
                </h3>
                <h4 className="vertical-timeline-element-subtitle">
                  {experience.Location}
                </h4>
                <ul>
                  {experience.Description.map((item, index) => (
                    <li key={index}>{item}</li>
                  ))}
                </ul>
              </VerticalTimelineElement>
            ))}
          </VerticalTimeline>
        </div>
      </div>
    </section>
  );
};

export default Experience;

File: ./src/features/Portfolio/containers/Main.tsx

import React from "react";
import Header from "../components/header/Header";
import Greeting from "./greeting/Greeting";
import Projects from "./projects/Projects";
import Experience from "./experience/Experience";
import "./Main.css";

interface MainProps {
  theme: {
    body: string;
    text: string;
    highlight: string;
    dark: string;
    secondaryText: string;
    accentColor: string;
    accentBright: string;
    projectCard: string;
    name: string;
  };
  setTheme: (theme: string) => void;
}

const Main: React.FC<MainProps> = ({ theme, setTheme }) => {
  return (
    <div className="portfolio-main">
      <Header theme={theme} setTheme={setTheme} />
      <div className="main" style={{ backgroundColor: theme.body }}>
        <div id="greeting">
          <Greeting theme={theme} />
        </div>
        <div id="projects">
          <Projects theme={theme} />
        </div>
        <div id="experience">
          <Experience theme={theme} />
        </div>
      </div>
    </div>
  );
};

export default Main;

File: ./src/features/Portfolio/containers/greeting/FeelingProud.tsx

import React from "react";

interface FeelingProudProps {
  theme: string;
  colors: {
    background: string;
    text: string;
    primary: string;
    secondary: string;
    accent: string;
    surface: string;
    border: string;
  };
}

const FeelingProud: React.FC<FeelingProudProps> = ({ theme }) => {
  return (
    <div className="feeling-proud-illustration">
      <img
        src="/illustrations/feeling_proud.svg"
        alt="Developer illustration"
        style={{
          maxWidth: "100%",
          height: "auto",
          filter: theme === "dark" ? "brightness(0.8)" : "none",
        }}
      />
    </div>
  );
};

export default FeelingProud;

File: ./src/features/Portfolio/containers/greeting/Greeting.tsx

import React from "react";
import "./Greeting.css";
import SocialMedia from "../../components/socialMedia/SocialMedia";
import { greeting } from "../../portfolio";
import { motion } from "framer-motion";
import { useNavigate } from "react-router-dom";
import FeelingProud from "./FeelingProud";
import { style } from "glamor";

interface GreetingProps {
  theme: string;
  colors: {
    background: string;
    text: string;
    primary: string;
    secondary: string;
    accent: string;
    surface: string;
    border: string;
  };
}

export default function Greeting({ theme, colors }: GreetingProps) {
  const navigate = useNavigate();

  const styles = style({
    backgroundColor: colors.accent,
    ":hover": {
      boxShadow: `0 5px 15px ${colors.accent}`,
    },
  });

  const powerButtonStyle = style({
    backgroundColor: colors.accent,
    color: colors.background,
    padding: "15px 30px",
    border: "none",
    borderRadius: "30px",
    fontSize: "1.2rem",
    cursor: "pointer",
    marginTop: "20px",
    transition: "all 0.3s ease-in-out",
    ":hover": {
      transform: "scale(1.05)",
      boxShadow: `0 5px 15px ${colors.accent}`,
    },
  });

  return (
    <motion.div
      className="greet-main"
      id="greeting"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 1 }}
    >
      <div className="greeting-main">
        <div className="greeting-text-div">
          <div>
            <motion.h1
              className="greeting-text"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.2, duration: 0.8 }}
            >
              {greeting.title}
            </motion.h1>
            <motion.p
              className="greeting-text-p subTitle"
              style={{ color: colors.secondary }}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.4, duration: 0.8 }}
            >
              <span>I'm </span>
              <span style={{ color: colors.accent }}>
                {greeting.full_name}.{" "}
              </span>
              {greeting.subTitle}
            </motion.p>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.6, duration: 0.8 }}
            >
              <SocialMedia />
            </motion.div>
            <motion.div
              className="portfolio-repo-btn-div"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.8, duration: 0.8 }}
            >
              <button
                {...styles}
                className="button"
                onClick={() => {
                  navigate("/contact");
                }}
              >
                Contact Me
              </button>
              <button
                {...powerButtonStyle}
                onClick={() => navigate("/desktop")}
              >
                View Interactive Desktop 🖥️
              </button>
            </motion.div>
            <motion.p
              style={{ marginTop: "15px", color: colors.secondary }}
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 1, duration: 0.8 }}
            >
              (Click to explore my macOS-style portfolio!)
            </motion.p>
          </div>
        </div>
        <motion.div
          className="greeting-image-div"
          initial={{ opacity: 0, x: 20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ delay: 0.4, duration: 0.8 }}
        >
          <FeelingProud theme={theme} colors={colors} />
        </motion.div>
      </div>
    </motion.div>
  );
}

File: ./src/features/Portfolio/containers/projects/Projects.tsx

import React from "react";
import { work } from "../../portfolio";
import Card from "../../components/card/Card";
import "./Projects.css";
import Carousel from "react-multi-carousel";
import "react-multi-carousel/lib/styles.css";

interface ProjectsProps {
  theme: {
    body: string;
    text: string;
    highlight: string;
    dark: string;
    secondaryText: string;
    accentColor: string;
    accentBright: string;
    projectCard: string;
    name: string;
  };
}

const responsive = {
  desktop: {
    breakpoint: { max: 3000, min: 1024 },
    items: 2,
    slidesToSlide: 2,
  },
  tablet: {
    breakpoint: { max: 1024, min: 464 },
    items: 1,
    slidesToSlide: 1,
  },
  mobile: {
    breakpoint: { max: 464, min: 0 },
    items: 1,
    slidesToSlide: 1,
  },
};

const Projects: React.FC<ProjectsProps> = ({ theme }) => {
  return (
    <section className="Project section" id="project">
      <div className="container">
        <h2 className="Project-h2 section-head" style={{ color: theme.text }}>
          Projects
        </h2>
        <div className="Project-wrapper">
          <Carousel
            responsive={responsive}
            autoPlay={true}
            autoPlaySpeed={2000}
            infinite={true}
            removeArrowOnDeviceType={["tablet", "mobile"]}
            containerClass="carousel-container"
            itemClass="carousel-item"
          >
            {work.map((project, index) => (
              <div key={`${project.name}-${index}`}>
                <Card
                  name={project.name}
                  description={project.description}
                  stack={project.stack}
                  linkProject={project.linkProject}
                  linkGithub={project.linkGithub}
                  theme={theme}
                />
              </div>
            ))}
          </Carousel>
        </div>
      </div>
    </section>
  );
};

export default Projects;

File: ./src/features/Portfolio/containers/Main/Main.tsx

import React, { useEffect } from "react";
import Header from "../../components/header/Header";
import Greeting from "../greeting/Greeting";
import Projects from "../projects/Projects";
import Experience from "../experience/Experience";
import { useTheme } from "../../../../context/ThemeContext";
import "./Main.css";

const Main: React.FC = () => {
  const { colors, theme } = useTheme();

  useEffect(() => {
    // Apply theme class to body when component mounts
    document.body.classList.add(`theme-${theme}`);
    return () => {
      // Clean up theme class when component unmounts
      document.body.classList.remove(`theme-${theme}`);
    };
  }, [theme]);

  if (!colors || !theme) {
    return (
      <div className="loading-container">
        <div className="loading-spinner">Loading...</div>
      </div>
    );
  }

  return (
    <div className="portfolio-main">
      <Header />
      <div className="main" style={{ backgroundColor: colors.background }}>
        <div id="greeting">
          <Greeting theme={theme} colors={colors} />
        </div>
        <div id="projects">
          <Projects theme={theme} colors={colors} />
        </div>
        <div id="experience">
          <Experience theme={theme} colors={colors} />
        </div>
      </div>
    </div>
  );
};

export default Main;

File: ./src/features/Topbar/components/Topbar.tsx

import { useEffect, useState } from "react";
import WeatherDisplay from "./WeatherDisplay";

export default function Topbar() {
  const [time, setTime] = useState(new Date());

  useEffect(() => {
    const timer = setInterval(() => setTime(new Date()), 1000);
    return () => clearInterval(timer);
  }, []);

  return (
    <div className="fixed top-0 left-0 w-full h-10 bg-gray-900/80 text-white flex items-center justify-between px-4 z-50 shadow-md">
      <div className="flex items-center gap-4">
        <span className="text-lg"></span>
        <span className="text-sm">Finder</span>
      </div>
      <div className="flex items-center gap-4">
        <WeatherDisplay />
        <div className="text-sm">
          {time.toLocaleTimeString([], { 
            hour: "2-digit", 
            minute: "2-digit",
            second: "2-digit"
          })}
        </div>
      </div>
    </div>
  );
}

File: ./src/features/Topbar/components/WeatherDisplay.tsx

import React, { useState, useEffect } from 'react';

const WeatherDisplay: React.FC = () => {
  const [weather, setWeather] = useState<{ temp: number; icon: string; city: string } | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchWeatherByLocation = async (latitude: number, longitude: number) => {
      try {
        const response = await fetch(
          `https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&units=metric&appid=59af8c71ad2dea30ab94fdb72a98ddab`
        );
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        if (data.main && data.weather && data.name) {
          setWeather({
            temp: Math.round(data.main.temp),
            icon: data.weather[0].icon,
            city: data.name
          });
        } else {
          console.error('Unexpected data format:', data);
        }
      } catch (error) {
        console.error('Error fetching weather:', error);
      } finally {
        setLoading(false);
      }
    };

    const getLocation = () => {
      if (!navigator.geolocation) {
        console.error('Geolocation is not supported by your browser');
        return;
      }

      navigator.geolocation.getCurrentPosition(
        (position) => {
          fetchWeatherByLocation(
            position.coords.latitude,
            position.coords.longitude
          );
        },
        (error) => {
          console.error('Error getting location:', error);
        }
      );
    };

    getLocation();
    const interval = setInterval(getLocation, 600000); // Update every 10 minutes
    return () => clearInterval(interval);
  }, []);

  if (loading || !weather) return null;

  return (
    <div className="flex items-center gap-2">
      <span className="text-sm">{weather.city}</span>
      <img
        src={`https://openweathermap.org/img/wn/${weather.icon}.png`}
        alt="Weather icon"
        className="w-5 h-5"
      />
      <span>{weather.temp}°C</span>
    </div>
  );
};

export default WeatherDisplay;
File: ./src/features/Dock/components/Dock.test.tsx

import { render } from "@testing-library/react";
import Dock from "./Dock";

test("renders Dock component", () => {
  render(<Dock openApp={() => {}} />);
  // Add more specific tests here
});

File: ./src/features/Dock/components/Dock.tsx

import { useRef } from "react";
import {
  motion,
  useMotionValue,
  useSpring,
  useTransform,
  animate,
  MotionValue,
} from "framer-motion";
import { useAppStore } from "@hooks/useAppStore";
import { apps } from "@shared/constants";
import { useWindowOpener } from "@hooks/useWindowOpener";

const SCALE = 1.75;
const DISTANCE = 70;
const NUDGE = 20;
const SPRING = {
  mass: 0.1,
  stiffness: 170,
  damping: 12,
};

interface Props {
  openApp: (appName: string, startPosition?: { x: number; y: number }) => void;
}

export default function Dock({}: Props) {
  const mouseLeft = useMotionValue(-Infinity);
  // const { openApps, minimizeApp, restoreApp } = useAppStore();
  const { openOrRestoreWindow } = useWindowOpener();

  const handleDockIconClick = (appName: string) => {
    openOrRestoreWindow(appName);
  };

  return (
    <motion.div
      className="fixed bottom-6 left-1/2 -translate-x-1/2 flex gap-4 px-8 py-6 bg-gray-900/70 backdrop-blur-lg rounded-2xl shadow-lg z-50"
      onMouseMove={(e) => {
        const { left } = e.currentTarget.getBoundingClientRect();
        mouseLeft.set(e.clientX - left);
      }}
      onMouseLeave={() => mouseLeft.set(-Infinity)}
    >
      {apps.map((app) => {
        // const isRunning = openApps.some((a) => a.appName === app.name);
        // const isMinimized = openApps.some(
        //   (a) => a.appName === app.name && a.minimized
        // );

        return (
          <DockItem
            key={app.name}
            app={app}
            openApp={() => handleDockIconClick(app.name)}
            mouseLeft={mouseLeft}
          />
        );
      })}
    </motion.div>
  );
}

interface DockItemProps {
  app: {
    name: string;
    icon: string;
    link?: string;
    defaultFile?: string;
  };
  openApp: () => void;
  mouseLeft: MotionValue<number>;
}

function DockItem({ app, openApp, mouseLeft }: DockItemProps) {
  const ref = useRef<HTMLDivElement>(null);
  const { openApps } = useAppStore();
  const isMinimized = openApps.some(
    (a) => a.appName === app.name && a.minimized
  );

  const distance = useTransform(() => {
    const bounds = ref.current
      ? { x: ref.current.offsetLeft, w: ref.current.offsetWidth }
      : { x: 0, w: 0 };
    return mouseLeft.get() - bounds.x - bounds.w / 2;
  });

  const scale = useTransform(distance, [-DISTANCE, 0, DISTANCE], [1, SCALE, 1]);
  const scaleSpring = useSpring(scale, SPRING);

  const x = useTransform(() => {
    const d = distance.get();
    if (d === -Infinity) return 0;
    if (Math.abs(d) > DISTANCE) return Math.sign(d) * -1 * NUDGE;
    return (-d / DISTANCE) * NUDGE * scale.get();
  });
  const xSpring = useSpring(x, SPRING);
  const y = useMotionValue(0);

  return (
    <motion.div
      ref={ref}
      style={{ x: xSpring, scale: scaleSpring, y }}
      className={`group relative flex flex-col items-center ${
        isMinimized ? "minimized" : ""
      }`}
      onClick={() => {
        animate(y, [0, -20, 0], {
          repeat: 2,
          duration: 0.7,
          ease: "easeInOut",
        });
        openApp();
      }}
    >
      <div className="w-20 h-20 flex items-center justify-center rounded-full bg-gray-800 shadow-md border border-gray-300 overflow-hidden">
        <motion.img
          src={app.icon}
          className="w-16 h-16 object-cover rounded-full"
          alt={app.name}
        />
      </div>

      {/* Label Above Icon (only visible on hover) */}
      <span className="absolute -top-10 bg-gray-900 text-white text-xs px-2 py-1 rounded-md opacity-0 group-hover:opacity-100 transition-opacity">
        {app.name}
      </span>

      {/* Add a dot indicator for minimized windows */}
      {isMinimized && (
        <div className="absolute -bottom-1 w-1 h-1 bg-white rounded-full" />
      )}
    </motion.div>
  );
}

File: ./src/shared/components/AppIcon/AppIcon.tsx

import { motion } from "framer-motion";

interface AppIconProps {
  name: string;
  icon: string;
  onClick?: () => void;
}

export default function AppIcon({ name, icon, onClick }: AppIconProps) {
  return (
    <div className="icon-wrapper" onClick={onClick}>
      <motion.img src={icon} className="icon-image" alt={name} />
    </div>
  );
}

File: ./src/shared/constants.ts

export const apps = [
  { name: "Finder", icon: "/icons/finder-icon.png" },
  { name: "Terminal", icon: "/icons/terminal.svg" },
  {
    name: "Resume",
    icon: "/icons/resume.webp",
    defaultFile: "/docs/Resume.pdf",
  },
  {
    name: "GitHub",
    icon: "/icons/github.webp",
    link: "https://github.com/Chrisyhjiang",
  },
  {
    name: "Readme",
    icon: "/icons/notes.png",
  },
];

File: ./src/vite-env.d.ts

/// <reference types="vite/client" />

File: ./src/hooks/useWindowOpener.ts

import { useAppStore } from "./useAppStore";
import { apps } from "@shared/constants";

export const useWindowOpener = () => {
  const { openApps, openApp, restoreApp } = useAppStore();

  const openOrRestoreWindow = (
    appName: string,
    options?: { filePath?: string }
  ) => {
    if (appName === "GitHub") {
      // Open GitHub profile in a new tab
      window.open(
        "https://github.com/Chrisyhjiang",
        "_blank",
        "noopener,noreferrer"
      );
      return;
    }

    const openedApp = openApps.find((a) => a.appName === appName);

    if (openedApp) {
      if (openedApp.minimized) {
        console.log(`[${appName}] Restoring minimized app`);
        restoreApp(appName);
      } else {
        console.log(`[${appName}] App already open`);
      }
    } else {
      console.log(`[${appName}] Opening new app`);
      // Correct center position calculation
      const startPosition = {
        x: (window.innerWidth - 600) / 2, // Center horizontally (assuming 600px width)
        y: (window.innerHeight - 400) / 2, // Center vertically (assuming 400px height)
      };

      // Check for default file if it's PDFViewer
      const appConfig = apps.find((a) => a.name === appName);
      const finalOptions = {
        ...options,
        startPosition,
        ...(appName === "Resume" && appConfig?.defaultFile
          ? { filePath: appConfig.defaultFile }
          : {}),
      };

      openApp(appName, finalOptions);
    }
  };

  return { openOrRestoreWindow };
};

File: ./src/hooks/useWindowManager.ts

import { create } from 'zustand';

interface WindowState {
  activeWindow: string | null;
  windowStack: string[];
  setActiveWindow: (windowId: string) => void;
  bringToFront: (windowId: string) => void;
  registerWindow: (windowId: string) => void;
}

export const useWindowManager = create<WindowState>((set) => ({
  activeWindow: null,
  windowStack: [],
  setActiveWindow: (windowId: string) => {
    console.log(`Setting active window: ${windowId}`);
    set({ activeWindow: windowId });
  },
  bringToFront: (windowId: string) => {
    console.log(`Bringing window to front: ${windowId}`);
    set((state) => {
      const newStack = [
        ...state.windowStack.filter(id => id !== windowId),
        windowId
      ];
      console.log(`Updated window stack: ${newStack}`);
      return {
        activeWindow: windowId,
        windowStack: newStack
      };
    });
  },
  registerWindow: (windowId: string) => {
    set((state) => ({
      windowStack: state.windowStack.includes(windowId) 
        ? state.windowStack 
        : [...state.windowStack, windowId]
    }));
  }
})); 
File: ./src/hooks/useAppStore.ts

import { create } from "zustand";
import { apps } from "@shared/constants";

interface WindowPosition {
  position: { x: number; y: number };
  size: { width: number; height: number };
}

interface DesktopIconState {
  position: { x: number; y: number };
  app: string;
}

interface AppState {
  openApps: {
    appName: string;
    minimized: boolean;
    lastPosition?: WindowPosition;
    startPosition?: { x: number; y: number };
    filePath?: string;
  }[];
  openApp: (
    appName: string,
    options?: { filePath?: string; startPosition?: { x: number; y: number } }
  ) => void;
  minimizeApp: (appName: string) => void;
  restoreApp: (appName: string) => void;
  closeApp: (appName: string) => void;
  setWindowPosition: (appName: string, position: WindowPosition) => void;
  completeRestore: (appName: string) => void;
  desktopIcons: DesktopIconState[];
  updateIconPosition: (
    appName: string,
    position: { x: number; y: number }
  ) => void;
  initializeDesktopIcons: () => void;
}

export const useAppStore = create<AppState>((set) => ({
  openApps: [],
  desktopIcons: [],

  openApp: (
    appName: string,
    options?: { filePath?: string; startPosition?: { x: number; y: number } }
  ) => {
    console.log(`[${appName}] Opening app with options:`, options);
    set((state) => ({
      openApps: [
        ...state.openApps,
        {
          appName,
          minimized: false,
          startPosition: options?.startPosition,
          ...options,
        },
      ],
    }));
  },

  minimizeApp: (appName: string) =>
    set((state) => ({
      openApps: state.openApps.map((app) =>
        app.appName === appName ? { ...app, minimized: true } : app
      ),
    })),

  restoreApp: (appName: string) => {
    console.log(`[${appName}] Restoring app`);
    set((state) => ({
      openApps: state.openApps.map((app) =>
        app.appName === appName ? { ...app, minimized: false } : app
      ),
    }));
  },

  completeRestore: (appName: string) =>
    set((state) => ({
      openApps: state.openApps.map((app) =>
        app.appName === appName ? { ...app, minimized: false } : app
      ),
    })),

  closeApp: (appName) =>
    set((state) => ({
      openApps: state.openApps.filter((app) => app.appName !== appName),
    })),

  setWindowPosition: (appName, position) =>
    set((state) => ({
      openApps: state.openApps.map((app) =>
        app.appName === appName ? { ...app, lastPosition: position } : app
      ),
    })),

  updateIconPosition: (appName, position) =>
    set((state) => ({
      desktopIcons: state.desktopIcons.map((icon) =>
        icon.app === appName ? { ...icon, position } : icon
      ),
    })),

  initializeDesktopIcons: () => {
    const initialIcons = apps.map((app, index) => ({
      app: app.name,
      position: {
        x: 20,
        y: 20 + index * 150,
      },
    }));

    set({ desktopIcons: initialIcons });
  },
}));


Directory structure of src excluding node_modules:

./src
├── App.css
├── App.tsx
├── assets
│   └── react.svg
├── context
│   └── ThemeContext.tsx
├── features
│   ├── Background
│   │   └── components
│   │       └── Background.tsx
│   ├── Desktop
│   │   ├── components
│   │   │   ├── Desktop.test.tsx
│   │   │   └── Desktop.tsx
│   │   ├── hooks
│   │   └── styles
│   ├── Dock
│   │   ├── components
│   │   │   ├── Dock.test.tsx
│   │   │   └── Dock.tsx
│   │   ├── hooks
│   │   └── styles
│   │       └── Dock.css
│   ├── Finder
│   │   ├── components
│   │   │   ├── Finder.test.tsx
│   │   │   └── Finder.tsx
│   │   ├── hooks
│   │   └── styles
│   │       └── Finder.css
│   ├── Loading
│   │   ├── Loading.tsx
│   │   └── styles
│   │       └── Loading.css
│   ├── PDFViewer
│   │   ├── components
│   │   │   ├── PDFViewer.test.tsx
│   │   │   └── PDFViewer.tsx
│   │   ├── hooks
│   │   └── styles
│   ├── Portfolio
│   │   ├── components
│   │   │   ├── card
│   │   │   │   ├── Card.css
│   │   │   │   └── Card.tsx
│   │   │   ├── header
│   │   │   │   ├── Header.css
│   │   │   │   └── Header.tsx
│   │   │   ├── icon
│   │   │   │   └── Icon.tsx
│   │   │   └── socialMedia
│   │   │       ├── SocialMedia.css
│   │   │       └── SocialMedia.tsx
│   │   ├── containers
│   │   │   ├── Main
│   │   │   │   ├── Main.css
│   │   │   │   └── Main.tsx
│   │   │   ├── Main.css
│   │   │   ├── Main.tsx
│   │   │   ├── experience
│   │   │   │   ├── Experience.css
│   │   │   │   └── Experience.tsx
│   │   │   ├── greeting
│   │   │   │   ├── FeelingProud.tsx
│   │   │   │   ├── Greeting.css
│   │   │   │   └── Greeting.tsx
│   │   │   └── projects
│   │   │       ├── Projects.css
│   │   │       └── Projects.tsx
│   │   └── portfolio.ts
│   ├── Readme
│   │   ├── components
│   │   │   └── Readme.tsx
│   │   └── styles
│   │       └── styles.css
│   ├── Terminal
│   │   ├── components
│   │   │   ├── Terminal.test.tsx
│   │   │   └── Terminal.tsx
│   │   ├── hooks
│   │   └── styles
│   ├── Topbar
│   │   ├── components
│   │   │   ├── Topbar.tsx
│   │   │   └── WeatherDisplay.tsx
│   │   ├── hooks
│   │   └── styles
│   │       └── WeatherDisplay.css
│   └── Window
│       ├── components
│       │   ├── Window.test.tsx
│       │   └── Window.tsx
│       ├── hooks
│       └── styles
│           └── Window.css
├── hooks
│   ├── useAppStore.ts
│   ├── useWindowManager.ts
│   └── useWindowOpener.ts
├── main.tsx
├── shared
│   ├── components
│   │   └── AppIcon
│   │       └── AppIcon.tsx
│   └── constants.ts
├── styles
│   ├── Window.css
│   ├── fonts.css
│   ├── global.css
│   └── index.css
└── vite-env.d.ts

55 directories, 57 files
